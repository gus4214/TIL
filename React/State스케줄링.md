# State스케줄링

리액트에서 상태는 가장 중요한 개념

상태라는 것은 컴포넌트를 다시 렌더링하고 화면에 표시되는 것들을 바꾼다.

👉 컴포넌트와 상태와의 상호작용은 리액트의 핵심적인 개념

이러한 컴포넌트의 개념은 리액트 라이브러리에서 나왔으며 리액트는 이 컴포넌트와 연결된 상태도 함께 처리한다.

가장 일반적인 상태 관리는 useState 훅을 사용하는 것이다.

---

<br />

## 리액트는 상태에 대한 갱신을 어떻게 할까?

![스크린샷 2022-11-18 오후 6.16.40.png](/React/Image/sheduling1.png)

위와 같이 내가 작성한 코드에는 컴포넌트가 있고

컴포넌트 안에는 useState Hook을 사용하여 일부 상태들을 관리할 수 있다.

👉 리액트가 상태를 관리해주는 것

`<Product />` 컴포넌트의 초기 상태는 “movie” 라고 해보자

즉, 여기에 영화 제품이 있는 것이다.

<br />

이제 사용자가 버튼을 누르거나 하면 컴포넌트 안에서는 상태가 갱신될 것이다.

![스크린샷 2022-11-18 오후 6.20.33.png](/React/Image/sheduling2.png)

`setNewProduct` 는 `useState` 를 통해 값을 반환하는 상태 갱신 함수

이제 이 제품을 movie 에서 Book으로 변경한다.

여기서 발생하는 일은, `setNewProduct` 가 실행이 완료되었지만, “movie”는 바로 변경되지는 않는다.

⇒ `setNewProduct` 실행이 끝났지만 movie는 즉각적으로 바뀌지 않는 것

<br />

![스크린샷 2022-11-18 오후 6.29.00.png](/React/Image/sheduling3.png)

대신 `setNewProduct` 를 호출하고 상태 업데이트 함수를 호출하면
Book 데이터로 상태 업데이트를 하게끔 **예약**을 한다.

👉 이것이 **상태 갱신 예약**

<br />

리액트는 이를 인지하고 있고, 처리할 계획을 준비하지만 이를 즉시 처리하지는 않는다.

대부분의 경우에는 상태 변경이 발생하면 상태 갱신에 대한 스케줄 작업은 매우 빠르게 발생한다. (거의 즉각적이나 다름 없음)

실제로는 순간적으로 발생하여 사람이 이를 보고 있으면 거의 즉시 작업이 처리된 것처럼 보인다.

🤔 하지만, 리액트는 이 상태 변화를 지연시키게 된다.

예를 들어, 대다수의 성능 기반의 작업들이 거의 동시에 진행되는데 잠재적으로 리액트는 더 높은 우선순위를 갖는 것으로 간주한다.

만약 화면에 사용자가 입력할 수 있는 공간이 있다고 해보자

사용자 입력에 응답하는 것이 > 화면에 문자를 변경하는 것보다는 **우선순위**가 높을 것

이러한 이유로 리액트는 예정된 상태 변경을 연기할 수 있다.

<br />

그래서 `setNewProduct` 를 다시 호출하고 이번엔 Gym 으로 바꿔보자

이러면 상태 변화는 이전의 상태 변화 전까지는 일어나지 않는다.

→ 즉 순서가 유지되는 것

<br />

하지만 즉각 실행이 필수적인 것은 아니다. 결국 언젠가는 처리가 되고 상태는 Book 으로 바뀔 것이다.

![스크린샷 2022-11-18 오후 6.38.26.png](/React/Image/sheduling4.png)

<br />

그리고 새로운 상태가 활성화되면, 상태 변화가 처리되면 리액트가 컴포넌트를 재평가 하고 컴포넌트 함수를 재실행 한다.

![스크린샷 2022-11-18 오후 6.41.43.png](/React/Image/sheduling5.png)

<br />

스케줄링 때문에 다수의 예약 상태 변화가 동시에 있을 수 있다.

![스크린샷 2022-11-18 오후 6.44.33.png](/React/Image/sheduling6.png)

이 때문에 동시에 여러 번의 갱신이 스케줄될 수 있으므로 상태를 갱신할 때는 함수 형태를 이용해서 갱신하는 것을 추천한다.

💡 특히 이전 상태에 의존해야 한다면!

```jsx
setShow((prevShow) => !prevShow);
```

사실 많은 경우에 이 것은 굉장히 빠르게 처리가 되기 때문에 크게 문제가 되지 않는다. → 잠깐의 지연조차 느끼지 못할 정도

But! 이론상으로는 이 스케줄링 작업은 지연될 수 있으므로 이는 상태 변경이 순서대로 처리되고 이전 상태를 기반으로 매 회 상태 변경이 발생할 때마다 **가장 최신의 상태**를 얻을 수 있게 해주는 **안전한 방법**이다.

<br />

그렇지 않다면 컴포넌트 함수가 마지막으로 실행될 때의 상태를 얻는다.

→ 이는 상태 변경이 순서대로 실행될 때와는 조금 다른 결과가 나올 수도 있다.

왜냐면 완료되지 않는 상태 변경 작업이 여러 개가 있다면 컴포넌트의 재 렌더링 주기는 모두 동일하기 때문이다.

함수 형태를 사용해야 리액트가 미완료된 상태 변경 작업에 대하여 최신의 상태를 사용하고 컴포넌트가 리렌더링되었을 그 시점의 상태를 사용하지 않게 된다.

👉 이 것이 함수 형태를 사용하는 것을 추천하는 이유이고 컴포넌트가 리렌더링 되었을 때의 시점과 상태 변경이 예약되는 시점의 차이를 아는 것은 매우 중요!!!

💡 하나의 컴포넌트가 재평가 되면서 미완료된 상태 변경 작업이 여러 개 있을 수 있다. → 이 것이 핵심
